<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BubbleChat</title>
<style>
  /* Basic reset */
  * { box-sizing: border-box; }
  html,body { height:100%; margin:0; background:#0f0f10; color:#eaeaea; font-family: "Courier New", monospace; }

  /* Container */
  .app {
    max-width: 1100px;
    height: 100vh;
    margin: 0 auto;
    display: grid;
    grid-template-rows: 120px 1fr 72px;
    grid-template-columns: 1fr 220px;
    grid-template-areas:
      "header header"
      "main sidebar"
      "input sidebar";
    gap: 8px;
    padding: 12px;
  }

  /* Header (big send-like pixel top) */
  .header {
    grid-area: header;
    background: linear-gradient(#e9e6df, #d8d4c8);
    border: 10px solid #0b0b0b;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:46px;
    color:#111;
    letter-spacing:6px;
    image-rendering: pixelated;
  }
  .header .caret { width:18px; height:34px; border-left:5px solid #000; margin-left:8px; animation:blink 1s steps(1) infinite; }
  @keyframes blink{50%{opacity:0}}

  /* Main chat area */
  .main {
    grid-area: main;
    background: #e9e9e9;
    padding: 12px;
    overflow-y: auto;
    border: 6px solid #0b0b0b;
    font-size: 16px;
    color: #111;
    image-rendering: pixelated;
  }

  .msg {
    margin-bottom:8px;
    display:flex;
    gap:8px;
    align-items:flex-start;
    word-break:break-word;
  }

  .nick {
    font-weight:700;
    cursor:pointer;
    user-select:none;
  }

  .text {
    white-space:pre-wrap;
  }

  /* mention highlight animation (blink a few times) */
  .mention {
    animation: mentionBlink 0.5s linear 4;
  }
  @keyframes mentionBlink {
    0% { background: #ffd6d6; }
    50% { background: transparent; }
    100% { background: #ffd6d6; }
  }

  /* Sidebar users */
  .sidebar {
    grid-area: sidebar;
    background:#f6f6f6;
    border:6px solid #0b0b0b;
    padding:10px;
    color:#111;
  }
  .sidebar h4 { margin:4px 0 8px 0; }
  .users { list-style:none; padding-left:12px; margin:0; }
  .users li { margin:6px 0; cursor:pointer; }

  /* Input area */
  .input {
    grid-area: input;
    display:flex;
    gap:8px;
    align-items:center;
    background: linear-gradient(#f3f3f3,#dedede);
    border:6px solid #0b0b0b;
    padding:10px;
  }
  input[type="text"], textarea {
    font-family: "Courier New", monospace;
    font-size:16px;
    padding:8px;
    border:3px solid #9aa;
    outline:none;
    background:#fff;
  }
  #nickField { width:180px; }
  #msgField { flex:1; height:44px; }
  button {
    padding:10px 14px;
    border:4px solid #0f5d79;
    background: linear-gradient(#fff,#cfd6db);
    cursor:pointer;
    font-family: "Courier New", monospace;
    font-size:16px;
  }

  /* Responsive layout for small screens */
  @media (max-width: 820px) {
    .app {
      grid-template-rows: 96px 1fr 72px;
      grid-template-columns: 1fr;
      grid-template-areas:
        "header"
        "main"
        "input";
      padding:8px;
    }
    .sidebar { display:none; }
  }

</style>
</head>
<body>
  <div class="app" id="app">
    <div class="header"><div>BubbleChat</div><div class="caret"></div></div>

    <div class="main" id="main"></div>

    <aside class="sidebar">
      <h4>Онлайн</h4>
      <ul class="users" id="users"></ul>
    </aside>

    <div class="input">
      <!-- Nick field shown but user only sets once; kept for convenience -->
      <input id="nickField" type="text" placeholder="Ник" maxlength="30" />
      <input id="msgField" type="text" placeholder="Напиши сообщение..." maxlength="1000" />
      <button id="sendBtn">Отправить</button>
      <button id="fsBtn">Render</button>
    </div>
  </div>

<script>
(function(){
  const main = document.getElementById('main');
const usersEl = document.getElementById('users');
  const nickField = document.getElementById('nickField');
  const msgField = document.getElementById('msgField');
  const sendBtn = document.getElementById('sendBtn');
  const fsBtn = document.getElementById('fsBtn');

  // nickname save/load
  let nick = localStorage.getItem('bubble_nick') || '';
  if (!nick) {
    // prompt once
    nick = (prompt('Введите ник для BubbleChat (будет сохранён):') || '').trim();
    if (!nick) nick = 'Гость' + Math.floor(Math.random()*1000);
    localStorage.setItem('bubble_nick', nick);
  }
  nickField.value = nick;

  // compute same deterministic color as server (HSL hash)
  function nickColor(name) {
    let h = 0;
    for (let i = 0; i < name.length; i++) h = (h * 31 + name.charCodeAt(i)) | 0;
    h = Math.abs(h) % 360;
    return hsl(${h},70%,55%);
  }

  // WebSocket
  const WS = (location.protocol === 'https:' ? 'wss:' : 'ws:') + '//' + location.host;
  const ws = new WebSocket(WS);

  // local online list
  let online = new Set();

  // ensure server knows our nick upon connect
  ws.addEventListener('open', () => {
    ws.send(JSON.stringify({ type: 'setNick', nick }));
  });

  // add message to UI
  function addMsg(obj, scroll = true) {
    // obj: { type:'chat', nick, color, text, ts }
    const wrap = document.createElement('div');
    wrap.className = 'msg';

    const nickSpan = document.createElement('span');
    nickSpan.className = 'nick';
    nickSpan.textContent = obj.nick;
    nickSpan.style.color = obj.color || nickColor(obj.nick);
    nickSpan.title = 'Нажми, чтобы ответить';

    // nickname click -> insert @nick into msg field
    nickSpan.addEventListener('click', () => {
      msgField.value = '@' + obj.nick + ' ';
      msgField.focus();
      msgField.selectionStart = msgField.value.length;
    });

    const textSpan = document.createElement('span');
    textSpan.className = 'text';
    textSpan.textContent = ': ' + obj.text;

    wrap.appendChild(nickSpan);
    wrap.appendChild(textSpan);

    // check mention for current user (exact match with @Nick or @nick at word boundary)
    const mentionRegex = new RegExp('(^|\\s)@' + escapeRegExp(nick) + '(\\b|\\s|$)', 'i');
    if (mentionRegex.test(obj.text)) {
      // add mention class to blink a few times
      wrap.classList.add('mention');
      // remove class after animation finish (0.5s * 4 = 2s)
      setTimeout(() => wrap.classList.remove('mention'), 2100);
      // optionally play a small sound or show title. (not added)
    }

    main.appendChild(wrap);
    if (scroll) main.scrollTop = main.scrollHeight;
  }

  function escapeRegExp(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

  // handle incoming WS
  ws.addEventListener('message', (ev) => {
    try {
      const data = JSON.parse(ev.data);

      // history array
      if (Array.isArray(data) && data.length && data[0].type) {
        // older versions might send raw arrays — handle gracefully
        data.forEach(item => item && item.type === 'chat' && addMsg(item));
        return;
      }

      if (data.type === 'history' && Array.isArray(data.data)) {
        // data.data is list of chat objects
        data.data.forEach(item => addMsg(item, false));
        // scroll to bottom after all added
        main.scrollTop = main.scrollHeight;
        return;
      }

      if (data.type === 'chat') {
        addMsg(data);
        // update online set if needed (we don't have users list from server in this version)
        // Optionally we could maintain online users if server sent that
        return;
      }
      // backwards compatibility: if message is chat object itself
      if (data.nick && data.text) {
        addMsg(data);
      }
    } catch (e) {
      console.error('Invalid WS msg', e);
    }
  });
// send message
  function sendMessage() {
    const text = msgField.value.trim();
    if (!text) return;
    // update stored nick if changed in UI
    const newNick = nickField.value.trim() || nick;
    if (newNick !== nick) {
      nick = newNick;
      localStorage.setItem('bubble_nick', nick);
      ws.send(JSON.stringify({ type: 'setNick', nick }));
    }
    const payload = { type: 'chat', text };
    ws.send(JSON.stringify(payload));
    msgField.value = '';
  }

  sendBtn.addEventListener('click', sendMessage);
  msgField.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') sendMessage();
  });

  // fullscreen render button
  fsBtn.addEventListener('click', () => {
    const app = document.getElementById('app');
    if (!document.fullscreenElement) {
      app.requestFullscreen && app.requestFullscreen();
    } else {
      document.exitFullscreen && document.exitFullscreen();
    }
  });

  // Optional: populate users from history (unique nicks)
  function populateUsersFromHistory() {
    const items = Array.from(document.querySelectorAll('.msg .nick')).map(el => ({
      nick: el.textContent,
      color: el.style.color
    }));
    const unique = {};
    items.forEach(it => { if (!unique[it.nick]) unique[it.nick] = it.color; });
    usersEl.innerHTML = '';
    Object.keys(unique).forEach(n => {
      const li = document.createElement('li');
      li.textContent = n;
      li.style.color = unique[n];
      li.addEventListener('click', () => {
        msgField.value = '@' + n + ' ';
        msgField.focus();
      });
      usersEl.appendChild(li);
    });
  }

  // rebuild users periodically from present messages
  setInterval(populateUsersFromHistory, 1500);

})();
</script>
</body>
</html>
